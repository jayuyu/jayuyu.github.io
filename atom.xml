<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Reverse</title>
  
  <subtitle>逆流而上，破解安卓玄机</subtitle>
  <link href="https://jayuyu.github.io/atom.xml" rel="self"/>
  
  <link href="https://jayuyu.github.io/"/>
  <updated>2025-03-25T14:27:26.186Z</updated>
  <id>https://jayuyu.github.io/</id>
  
  <author>
    <name>jayuyu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>去除花指令</title>
    <link href="https://jayuyu.github.io/posts/4f0/"/>
    <id>https://jayuyu.github.io/posts/4f0/</id>
    <published>2025-03-21T16:00:00.000Z</published>
    <updated>2025-03-25T14:27:26.186Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://bbs.kanxue.com/thread-279604.htm#msg_header_h2_5">https://bbs.kanxue.com/thread-279604.htm#msg_header_h2_5</a></p><p><a href="https://blog.csdn.net/abel_big_xu/article/details/117927674">https://blog.csdn.net/abel_big_xu&#x2F;article&#x2F;details&#x2F;117927674</a></p><p>花指令一直是逆向的一个比较常见而多变的东西，对于逆向人员来说也是一个比较大的阻碍，随着反编译工具的升级，现在的IDA9.0已经可以忽视一些花指令正常反编译，不过对于逆向人员还是要掌握</p><p>下面我用原理-&gt;形式-&gt;去除来讲解CTF比赛中经常的花指令</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p> <strong>花指令的核心原理是通过在代码中插入不影响程序实际行为的指令，来迷惑分析者或调试器。它们一般不执行有用的操作</strong>，但能让程序看起来更复杂或者改变程序的行为，从而导致逆向工程的困难。  </p><p>也就是IDA在反编译程序的时候是从函数的入口至上而下一一把机器码转换成汇编语言再变成c语言程序</p><h2 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h2><h3 id="永真永假跳转"><a href="#永真永假跳转" class="headerlink" title="永真永假跳转"></a>永真永假跳转</h3><p>这种花指令可以说是最基础也是最常见的花指令，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dummy_function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这个函数仅作为花指令的目标</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a dummy function.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        xor eax, eax      </span><br><span class="line">        test eax, eax      </span><br><span class="line">        jz target_label    </span><br><span class="line">        jnz target_label   </span><br><span class="line">        _emit <span class="number">0xe8</span></span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">    target_label:</span><br><span class="line">        call dummy_function </span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如以上代码，这里正常运行是不会接触到第15行代码，而我们说了IDA的线性扫描，自然会把0xe8当作机器码反编译，这个时候IDA就会看不懂了，就会出现这里的爆红</p><p><img src="/1742824537300-1081ab69-2e5f-4c80-91d1-5d1ad39d513c.png"></p><h4 id="去除方法"><a href="#去除方法" class="headerlink" title="去除方法"></a>去除方法</h4><p>既然会错误的把junkcode反编译，那我们的应对措施自然就是删除这个机器码了，在FA那个标签出先按U，转化成无定义，再把0E8h指令的下面按C，最后删除nop掉这个0E8h就行，记得在函数开头按P正常反编译为函数就行</p><p><img src="/1742824790052-33ee579f-3ee9-467a-8a29-090da4f42da4.png"></p><h3 id="永真永假跳转2"><a href="#永真永假跳转2" class="headerlink" title="永真永假跳转2"></a>永真永假跳转2</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dummy_function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这个函数仅作为花指令的目标</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a dummy function.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">_asm &#123;</span><br><span class="line">test eax, <span class="number">0</span>         <span class="comment">// 构造必然条件实现跳转，绕过破坏堆栈平衡的指令</span></span><br><span class="line">jz label</span><br><span class="line">add esp, <span class="number">0x1</span></span><br><span class="line">label:</span><br><span class="line">call dummy_function</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个test eax，0</p><p> 将寄存器 <code>eax</code> 和常数 <code>0</code> 进行按位与运算，但由于与 <code>0</code> 按位与的结果总是 <code>0</code></p><p>所以会直接跳转到label处，不会执行这个add esp，0x1</p><h4 id="去除方法-1"><a href="#去除方法-1" class="headerlink" title="去除方法"></a>去除方法</h4><p>其实这种花指令都不需要怎么去除，一般现在IDA都会自己识别出来，当然，也可以直接删除它绕过的部分</p><h3 id="call-ret"><a href="#call-ret" class="headerlink" title="call&amp;ret"></a>call&amp;ret</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_asm&#123;</span><br><span class="line">   call label</span><br><span class="line">   label:</span><br><span class="line">   add [esp],<span class="number">5</span></span><br><span class="line">   ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用极客大挑战的CPP-flower为例</p><p><img src="/1742873262770-512694e9-f879-47d7-a2cb-f7e4d4b9731b.png"></p><p>可以看见，这里的call419DA6，会跳到这个函数，而且这个函数没有做其他的操作，</p><p><img src="/1742873363751-68228de7-ca5b-4a26-852d-3c6556240883.png"></p><p>仔细观察这里，esp+4是在返回地址处，也就是call指令的下面的地址，之后这个值+12，说明返回地址加了12h，这里手动计算一下，本来的返回地址是</p><p>00419DA1，现在变成了00419DB3，所以正常流程就是这样</p><h4 id="去除方法-2"><a href="#去除方法-2" class="headerlink" title="去除方法"></a>去除方法</h4><p>因为返回地址直接跳到了B3地址，所以我们直接nop掉9C-B2的全部指令就行</p><p><img src="/1742873522082-93192b9e-fdd8-4b46-ae5d-ea0a891c57fe.png"></p><p>这里可以看出红色的地址没有连接上，这样直接去函数开头按u，c，p的话就会只能一半，这里的办法是删除这个sub_419DA6函数</p><p><img src="/1742873744607-c81277ff-44b0-4d6c-8433-20e70a67a5d2.png"></p><p>点击delte function就可以了</p><h3 id="杂糅指令"><a href="#杂糅指令" class="headerlink" title="杂糅指令"></a>杂糅指令</h3><p>我自己取的名字，这种花是比较难的了，有幸在VN赛题里面看到过</p><p><img src="/1742882969563-96d8e460-7e38-4628-8bb7-e0d07854eaf4.png"></p><p>普通的返回值，这个背景是初始化函数，我一直绕不过反调试，所以去找的初始化函数，但是点开汇编却另有玄机</p><p><img src="/1742883034371-1ef84494-d301-4996-989a-64fd4c7b2cf8.png"></p><p>直接爆红了，有反调试</p><p>像这种call    $+5指令的意思就是跳转到call的下一条指令去执行，并且把下面的地址压入栈中当返回地址，这里前面还有push eax 和pop eax</p><h4 id="去除方法-3"><a href="#去除方法-3" class="headerlink" title="去除方法"></a>去除方法</h4><p>所以直接nop掉这个push 到pop</p><p><img src="/1742883647394-264a0b14-6214-453b-bd92-0ecef41dd075.png"></p><p><img src="/1742883660069-792f5b27-4863-4cc4-a8d6-8433e6647dd4-1742912827257-10.png"></p><p>之后正常反编译出来了，这里插一个细节，如果想要修改指令去去除反调试的话直接</p><p><img src="/1742883722000-9916d798-a5a8-4bc5-a006-778b716d061f.png"></p><p>Apply patches to 保存就可以了。</p><h3 id="花指令-异常"><a href="#花指令-异常" class="headerlink" title="花指令+异常"></a>花指令+异常</h3><p><img src="/1742540279039-c9f2fbab-2543-4e30-8aea-1d5794e7f3a6.png"></p><p>这里分析了之后发现如果是调试的话就会直接jmp   eax，如果没有的话就是先加再jmp</p><p>像这种花的话是会影响程序运行的，直接看懂，能调试就行了</p><h3 id="堆区过大"><a href="#堆区过大" class="headerlink" title="堆区过大"></a>堆区过大</h3><p>参考文章</p><p><a href="https://hex-rays.com/blog/igors-tip-of-the-week-147-fixing-stack-frame-is-too-big">https://hex-rays.com/blog/igors-tip-of-the-week-147-fixing-stack-frame-is-too-big</a></p><p><img src="/1741699580098-9ce70f1b-af88-44c7-9785-d478e69a47ca.png"></p><p>这种的代码，入栈的数据太大了，考虑去代码里面找找这个参数，考虑删掉，因为堆区太大影响力编译，当然，也有可能是因为中间在删掉花指令的时候误删了导致的</p><h2 id="idapython自动去除花指令"><a href="#idapython自动去除花指令" class="headerlink" title="idapython自动去除花指令"></a>idapython自动去除花指令</h2><p>如果一个程序花指令过于多的花，就可以尝试idapython直接手动去除</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> ida_bytes</span><br><span class="line"></span><br><span class="line">begin = xxxxxx</span><br><span class="line">end = xxxxxx</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(begin, end):</span><br><span class="line">    <span class="keyword">if</span> idc.get_wide_byte(i) == <span class="number">0x74</span>:          <span class="comment">#修改为机器码</span></span><br><span class="line">        <span class="keyword">if</span> idc.get_wide_byte(i + <span class="number">1</span>) == <span class="number">0xFA</span>:</span><br><span class="line">            ida_bytes.patch_byte(i, <span class="number">0x90</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;junkcode noped at address: 0x&#123;:X&#125;&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;done&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://bbs.kanxue.com/thread-279604.htm#msg_header_h2_5&quot;&gt;https://bbs.kanxue.com/thread-279604.htm#msg_header_h2_5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a</summary>
      
    
    
    
    <category term="技术" scheme="https://jayuyu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>NCTF2025</title>
    <link href="https://jayuyu.github.io/posts/4f04/"/>
    <id>https://jayuyu.github.io/posts/4f04/</id>
    <published>2025-01-21T16:00:00.000Z</published>
    <updated>2025-03-25T15:19:04.581Z</updated>
    
    <content type="html"><![CDATA[<p>X1c@dM1n1$t</p><p>7d53ecd36a43d3d2</p><p>37e7dd633dcf8497</p><p>409EEC86B884A58B7E8A64E21AD3B8BB</p><h2 id="x1login"><a href="#x1login" class="headerlink" title="x1login"></a>x1login</h2><h3 id="过检测"><a href="#过检测" class="headerlink" title="过检测"></a>过检测</h3><p>首先我们先下载这个题目，因为我的手机开启了root权限所以直接退出了，这里我们直接看看这个，我第一想法是hook这个root检测和debugger检测</p><p><img src="/1742735040970-92857c31-ab88-45be-b08f-6164652837ef.png"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">MainActivity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.nctf.simplelogin.MainActivity&#x27;</span>); <span class="comment">// 根据实际类名修改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hook checkSecutity</span></span><br><span class="line">    <span class="title class_">MainActivity</span>.<span class="property">checkSecutity</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Bypassed Security Check&#x27;</span>);</span><br><span class="line">        <span class="comment">// 不执行原方法，相当于直接跳过</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hook started!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就可以直接hook掉了这个检测，可以看到叫我们输入用户名和密码，这里看看逻辑吧,其实可以看出是一个动态加载的dex</p><p>这里给一下简单的API</p><h3 id="动态加载的dex"><a href="#动态加载的dex" class="headerlink" title="动态加载的dex"></a>动态加载的dex</h3><p><strong>InMemoryDexClassLoader</strong><br>这是 Android 9（API 28）引入的一个类加载器，用于从内存中的字节数组加载 Dex 文件。代码中通过 <code>new InMemoryDexClassLoader(ByteBuffer.wrap(...), getClassLoader())</code> 来实现 Dex 的内存加载。使用这个 API 可以避免将 Dex 文件写入存储，从而减少被提取和逆向的风险。  </p><p><img src="/1742735830592-62d7ca3b-1652-42e1-896d-7fc057196f15.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/48373702/1742735838730-81cdf1a5-ab8c-40b9-aac6-116ef2c59414.png"></p><p>自己实现的解密这些字符串</p><p>相当于字符串加密了，这里我们自己去调用这个native方法去实现解密就行（因为直接看native方法看不懂）</p><p>这里本地调用一下这个方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">DecStr</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.nctf.simplelogin.DecStr&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hook get 方法</span></span><br><span class="line">    <span class="title class_">DecStr</span>.<span class="property">get</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">encryptedData</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] DecStr.get called&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用原始的 get 方法</span></span><br><span class="line">        <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">get</span>(encryptedData);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] DecStr.get returned: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你可以在这里传入你知道的密文，假设它是某种字节数组或字符串</span></span><br><span class="line">    <span class="keyword">var</span> encryptedUsername = <span class="string">&quot;Exv3nhr5BNW0axn3aNz/DNv9C3q0wxj/Exe=&quot;</span>;  <span class="comment">// 你可以将密文作为字节数组或者字符串传入</span></span><br><span class="line">    <span class="keyword">var</span> encryptedUsername1 = <span class="string">&quot;zM1GzM4=&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> encryptedUsername2 = <span class="string">&quot;agDYB3bJ&quot;</span>;</span><br><span class="line">    <span class="comment">// 调用 DecStr.get 获取解密后的用户名</span></span><br><span class="line">    <span class="keyword">var</span> decryptedUsername = <span class="title class_">DecStr</span>.<span class="title function_">get</span>(encryptedUsername);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] Decrypted Username: &quot;</span> + decryptedUsername);</span><br><span class="line">    <span class="keyword">var</span> decryptedUsername = <span class="title class_">DecStr</span>.<span class="title function_">get</span>(encryptedUsername1);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] Decrypted Username: &quot;</span> + decryptedUsername);</span><br><span class="line">    <span class="keyword">var</span> decryptedUsername = <span class="title class_">DecStr</span>.<span class="title function_">get</span>(encryptedUsername2);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] Decrypted Username: &quot;</span> + decryptedUsername);</span><br></pre></td></tr></table></figure><p><img src="/1742736205464-07694d87-91eb-4bd4-ac15-fa2172c7c592.png"></p><p>所以这个就是一个动态加载的这个check类，对于这种动态加载的类，我们的办法就是本地dump下这个动态加载的dex，然后去复制到sdcard，再给权限再去拖出来看</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">InMemoryDexClassLoader</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;dalvik.system.InMemoryDexClassLoader&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hook 构造函数 - 你要 hook 动态加载的类</span></span><br><span class="line">    <span class="keyword">var</span> constructor = <span class="title class_">InMemoryDexClassLoader</span>.<span class="property">$init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[Ljava.nio.ByteBuffer;&#x27;</span>, <span class="string">&#x27;java.lang.ClassLoader&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hook 该构造函数</span></span><br><span class="line">    constructor.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">byteBuffers, classLoader</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] InMemoryDexClassLoader initialized&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 DEX 文件的字节数据</span></span><br><span class="line">        <span class="keyword">var</span> dexBytes = byteBuffers[<span class="number">0</span>].<span class="title function_">array</span>(); <span class="comment">// 获取 byteBuffer 中的字节数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存 DEX 到文件</span></span><br><span class="line">        <span class="title function_">saveDexToFile</span>(dexBytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用原始构造函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.$init(byteBuffers, classLoader);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存 DEX 文件的函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">saveDexToFile</span>(<span class="params">dexBytes</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取文件路径（例如存储到 /data/data/your.package/files 目录）</span></span><br><span class="line">            <span class="keyword">var</span> path = <span class="string">&#x27;/data/data/com.nctf.simplelogin/files/dynamic_login.dex&#x27;</span>; <span class="comment">// 你可以根据实际情况修改路径</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取 FileOutputStream 类</span></span><br><span class="line">            <span class="keyword">var</span> <span class="title class_">FileOutputStream</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.io.FileOutputStream&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 FileOutputStream 对象</span></span><br><span class="line">            <span class="keyword">var</span> fileOutputStream = <span class="title class_">FileOutputStream</span>.$new(path);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取字节数组的长度</span></span><br><span class="line">            <span class="keyword">var</span> byteArray = <span class="title class_">Java</span>.<span class="title function_">array</span>(<span class="string">&#x27;byte&#x27;</span>, dexBytes); <span class="comment">// 确保我们传递的是一个字节数组</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用正确的 write() 重载，将字节数组写入文件</span></span><br><span class="line">            fileOutputStream.<span class="title function_">write</span>(byteArray);  <span class="comment">// 传入字节数组</span></span><br><span class="line"></span><br><span class="line">            fileOutputStream.<span class="title function_">close</span>();</span><br><span class="line"></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] DEX file saved to: &quot;</span> + path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Error saving DEX: &quot;</span> + e.<span class="property">message</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/1742736450120-e6e04822-e95c-4b49-aab5-0d6f72763a99.png"></p><p>这里看出大致逻辑就是对用户名进行判断了，根据我们前面的frida主动调用解密可以得到明文，所以用户名很快就能得到，之后就差密码了，这里的密码的逻辑就是这个用户名进行md5加密再用密码一起传入这个Secure.doCheck方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[*] <span class="title class_">Decrypted</span> <span class="title class_">Username</span>: X1c@dM1n1$t</span><br></pre></td></tr></table></figure><p><img src="/1742736655151-5f32a412-ce72-4cac-b22c-7019b64347c9.png"></p><p>调用的就是native层的libnative.so文件了。</p><p><img src="/1742736869102-195dabc8-bf80-4b12-b57a-3dafac284b33.png"></p><p>我们在导出表中没有看到这个doCheck方法，这里</p><p><img src="/1742737102915-3b040159-f9f9-4c7c-9b20-f416a83fde17.png"></p><p>看出应该是动态注册的方法，也看到了这个loaddex的方法,这里我们就看一下这个docheck方法吧</p><p><img src="/1742737187013-31e118da-334c-46f1-ab88-fcb039bf1f54.png"></p><p>这里可以发现加密是Triple DES的加密的，这里我直接把这个密文拿去解密一直是不行的，后来才想到应该是大小端序的问题。</p><p>密钥应该就是我们输入的用户名经过md5加密后的字符串，用户名明文，可惜这里一直不行，后来想这个密钥是8字节，加密解密是不同的密钥，md5是16字节，那么我们按照8字节拆分</p><p>7d53ecd36a43d3d2</p><p>37e7dd633dcf8497</p><p>并且要是小端序，与之同时，我们的密文也要是小端序，每8字节</p><p>整理前的密文是409EEC86B884A58B7E8A64E21AD3B8BBDF4BFA1246453E52</p><p>所以整理的话密钥就是</p><p>d2d3436ad3ec537d9784cf3d63dde737d2d3436ad3ec537d</p><p>整理后的密文是</p><p>523E454612FA4BDFBBB8D31AE2648A7E8BA584B886EC9E40</p><p><img src="/1742738195535-4dc3184b-7b01-42f9-8553-78a9cb72709f.png"></p><p>就可以得到密码了，最后flag就是用户名_密码就行了。</p><h2 id="Safe-program"><a href="#Safe-program" class="headerlink" title="Safe_program"></a>Safe_program</h2><p><img src="/1742738479523-973115cf-b7aa-48bd-84bb-4b6637c4794a.png"></p><p>第一次用超强9.0，这里的大致逻辑就先判断输入的格式和长度，之后进行加密，只不过这里调试就要飞,这里看看导出表发现有TLS回调函数，会在这个主函数加载之前就执行</p><p><img src="/1742738767139-17cebc5a-33f2-4da5-9320-82f94246fca5.png"></p><p>发现有一个激起除零异常的函数，结合我们一调试就异常可以初步判断这个函数就是在反调试，这里直接apply patch是，改成强制跳转</p><p><img src="/1742738989761-7b62bc3f-fb89-491c-9b55-91f3b435b316.png"></p><p>这里可以看出就是SM4魔改的加密，因为直接用原版的解密方式是不行的，这里的方法就是去看，首先去出题人最喜欢的加密前后看看有没有其他的操作，比如对密钥进行异或，对明文数据进行异或，或者对加密的S盒进行替换，这里看出是对SM4的S盒进行的替换，我们其实可以先随便输入数据，然后调试去验证判断</p><p><img src="/1742739228604-8771c6f7-7dc9-42eb-aa56-475eefc62c54.png"></p><p>这里的S盒是不一样的，密钥可以直接调试给出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SM4_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SM4_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> u8 unsigned char</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> u32 unsigned long</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">four_uCh2uLong</span><span class="params">(u8* in, u32* out)</span>;             <span class="comment">//四字节转换成u32</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uLong2four_uCh</span><span class="params">(u32 in, u8* out)</span>;              <span class="comment">//u32转换成四字节</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">move</span><span class="params">(u32 data, <span class="type">int</span> length)</span>;          <span class="comment">//左移，保留丢弃位放置尾部</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">func_key</span><span class="params">(u32 input)</span>;                 <span class="comment">//先使用Sbox进行非线性变化，再将线性变换L置换为L&#x27;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">func_data</span><span class="params">(u32 input)</span>;                <span class="comment">//先使用Sbox进行非线性变化，再进行线性变换L</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_hex</span><span class="params">(u8* data, <span class="type">int</span> len)</span>;                 <span class="comment">//无符号字符数组转16进制打印</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">encode_fun</span><span class="params">(u8 len, u8* key, u8* input, u8* output)</span>;   <span class="comment">//加密函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decode_fun</span><span class="params">(u8 len, u8* key, u8* input, u8* output)</span>;   <span class="comment">//解密函数</span></span><br><span class="line"><span class="comment">/******************************定义系统参数FK的取值****************************************/</span></span><br><span class="line"><span class="type">const</span> u32 TBL_SYS_PARAMS[<span class="number">4</span>] = &#123;</span><br><span class="line"></span><br><span class="line"><span class="number">0xa3b1bac6</span>,</span><br><span class="line"><span class="number">0x56aa3350</span>,</span><br><span class="line"><span class="number">0x677d9197</span>,</span><br><span class="line"><span class="number">0xb27022dc</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/******************************定义固定参数CK的取值****************************************/</span></span><br><span class="line"><span class="type">const</span> u32 TBL_FIX_PARAMS[<span class="number">32</span>] = &#123;</span><br><span class="line"></span><br><span class="line"><span class="number">0x00070e15</span>,<span class="number">0x1c232a31</span>,<span class="number">0x383f464d</span>,<span class="number">0x545b6269</span>,</span><br><span class="line"><span class="number">0x70777e85</span>,<span class="number">0x8c939aa1</span>,<span class="number">0xa8afb6bd</span>,<span class="number">0xc4cbd2d9</span>,</span><br><span class="line"><span class="number">0xe0e7eef5</span>,<span class="number">0xfc030a11</span>,<span class="number">0x181f262d</span>,<span class="number">0x343b4249</span>,</span><br><span class="line"><span class="number">0x50575e65</span>,<span class="number">0x6c737a81</span>,<span class="number">0x888f969d</span>,<span class="number">0xa4abb2b9</span>,</span><br><span class="line"><span class="number">0xc0c7ced5</span>,<span class="number">0xdce3eaf1</span>,<span class="number">0xf8ff060d</span>,<span class="number">0x141b2229</span>,</span><br><span class="line"><span class="number">0x30373e45</span>,<span class="number">0x4c535a61</span>,<span class="number">0x686f767d</span>,<span class="number">0x848b9299</span>,</span><br><span class="line"><span class="number">0xa0a7aeb5</span>,<span class="number">0xbcc3cad1</span>,<span class="number">0xd8dfe6ed</span>,<span class="number">0xf4fb0209</span>,</span><br><span class="line"><span class="number">0x10171e25</span>,<span class="number">0x2c333a41</span>,<span class="number">0x484f565d</span>,<span class="number">0x646b7279</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/******************************SBox参数列表****************************************/</span></span><br><span class="line"><span class="type">const</span> u8 TBL_SBOX[<span class="number">256</span>] = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="number">0xD1</span>, <span class="number">0x90</span>, <span class="number">0xE9</span>, <span class="number">0xFE</span>, <span class="number">0xCC</span>, <span class="number">0xE1</span>, <span class="number">0x3D</span>, <span class="number">0xB7</span>, <span class="number">0x16</span>, <span class="number">0xB6</span>, <span class="number">0x14</span>, <span class="number">0xC2</span>, <span class="number">0x28</span>, <span class="number">0xFB</span>, <span class="number">0x2C</span>, <span class="number">0x05</span>,</span><br><span class="line">    <span class="number">0x2B</span>, <span class="number">0x67</span>, <span class="number">0x9A</span>, <span class="number">0x76</span>, <span class="number">0x2A</span>, <span class="number">0xBE</span>, <span class="number">0x04</span>, <span class="number">0xC3</span>, <span class="number">0xAA</span>, <span class="number">0x44</span>, <span class="number">0x13</span>, <span class="number">0x26</span>, <span class="number">0x49</span>, <span class="number">0x86</span>, <span class="number">0x06</span>, <span class="number">0x99</span>,</span><br><span class="line">    <span class="number">0x9C</span>, <span class="number">0x42</span>, <span class="number">0x50</span>, <span class="number">0xF4</span>, <span class="number">0x91</span>, <span class="number">0xEF</span>, <span class="number">0x98</span>, <span class="number">0x7A</span>, <span class="number">0x33</span>, <span class="number">0x54</span>, <span class="number">0x0B</span>, <span class="number">0x43</span>, <span class="number">0xED</span>, <span class="number">0xCF</span>, <span class="number">0xAC</span>, <span class="number">0x62</span>,</span><br><span class="line">    <span class="number">0xE4</span>, <span class="number">0xB3</span>, <span class="number">0x17</span>, <span class="number">0xA9</span>, <span class="number">0x1C</span>, <span class="number">0x08</span>, <span class="number">0xE8</span>, <span class="number">0x95</span>, <span class="number">0x80</span>, <span class="number">0xDF</span>, <span class="number">0x94</span>, <span class="number">0xFA</span>, <span class="number">0x75</span>, <span class="number">0x8F</span>, <span class="number">0x3F</span>, <span class="number">0xA6</span>,</span><br><span class="line">    <span class="number">0x47</span>, <span class="number">0x07</span>, <span class="number">0xA7</span>, <span class="number">0x4F</span>, <span class="number">0xF3</span>, <span class="number">0x73</span>, <span class="number">0x71</span>, <span class="number">0xBA</span>, <span class="number">0x83</span>, <span class="number">0x59</span>, <span class="number">0x3C</span>, <span class="number">0x19</span>, <span class="number">0xE6</span>, <span class="number">0x85</span>, <span class="number">0xD6</span>, <span class="number">0xA8</span>,</span><br><span class="line">    <span class="number">0x68</span>, <span class="number">0x6B</span>, <span class="number">0x81</span>, <span class="number">0xB2</span>, <span class="number">0xFC</span>, <span class="number">0x64</span>, <span class="number">0xDA</span>, <span class="number">0x8B</span>, <span class="number">0xF8</span>, <span class="number">0xEB</span>, <span class="number">0x0F</span>, <span class="number">0x4B</span>, <span class="number">0x70</span>, <span class="number">0x56</span>, <span class="number">0x9D</span>, <span class="number">0x35</span>,</span><br><span class="line">    <span class="number">0x1E</span>, <span class="number">0x24</span>, <span class="number">0x0E</span>, <span class="number">0x78</span>, <span class="number">0x63</span>, <span class="number">0x58</span>, <span class="number">0x9F</span>, <span class="number">0xA2</span>, <span class="number">0x25</span>, <span class="number">0x22</span>, <span class="number">0x7C</span>, <span class="number">0x3B</span>, <span class="number">0x01</span>, <span class="number">0x21</span>, <span class="number">0xC9</span>, <span class="number">0x87</span>,</span><br><span class="line">    <span class="number">0xD4</span>, <span class="number">0x00</span>, <span class="number">0x46</span>, <span class="number">0x57</span>, <span class="number">0x5E</span>, <span class="number">0xD3</span>, <span class="number">0x27</span>, <span class="number">0x52</span>, <span class="number">0x4C</span>, <span class="number">0x36</span>, <span class="number">0x02</span>, <span class="number">0xE7</span>, <span class="number">0xA0</span>, <span class="number">0xC4</span>, <span class="number">0xC8</span>, <span class="number">0x9E</span>,</span><br><span class="line">    <span class="number">0xEA</span>, <span class="number">0xBF</span>, <span class="number">0x8A</span>, <span class="number">0xD2</span>, <span class="number">0x40</span>, <span class="number">0xC7</span>, <span class="number">0x38</span>, <span class="number">0xB5</span>, <span class="number">0xA3</span>, <span class="number">0xF7</span>, <span class="number">0xF2</span>, <span class="number">0xCE</span>, <span class="number">0xF9</span>, <span class="number">0x61</span>, <span class="number">0x15</span>, <span class="number">0xA1</span>,</span><br><span class="line">    <span class="number">0xE0</span>, <span class="number">0xAE</span>, <span class="number">0x5D</span>, <span class="number">0xA4</span>, <span class="number">0x9B</span>, <span class="number">0x34</span>, <span class="number">0x1A</span>, <span class="number">0x55</span>, <span class="number">0xAD</span>, <span class="number">0x93</span>, <span class="number">0x32</span>, <span class="number">0x30</span>, <span class="number">0xF5</span>, <span class="number">0x8C</span>, <span class="number">0xB1</span>, <span class="number">0xE3</span>,</span><br><span class="line">    <span class="number">0x1D</span>, <span class="number">0xF6</span>, <span class="number">0xE2</span>, <span class="number">0x2E</span>, <span class="number">0x82</span>, <span class="number">0x66</span>, <span class="number">0xCA</span>, <span class="number">0x60</span>, <span class="number">0xC0</span>, <span class="number">0x29</span>, <span class="number">0x23</span>, <span class="number">0xAB</span>, <span class="number">0x0D</span>, <span class="number">0x53</span>, <span class="number">0x4E</span>, <span class="number">0x6F</span>,</span><br><span class="line">    <span class="number">0xD5</span>, <span class="number">0xDB</span>, <span class="number">0x37</span>, <span class="number">0x45</span>, <span class="number">0xDE</span>, <span class="number">0xFD</span>, <span class="number">0x8E</span>, <span class="number">0x2F</span>, <span class="number">0x03</span>, <span class="number">0xFF</span>, <span class="number">0x6A</span>, <span class="number">0x72</span>, <span class="number">0x6D</span>, <span class="number">0x6C</span>, <span class="number">0x5B</span>, <span class="number">0x51</span>,</span><br><span class="line">    <span class="number">0x8D</span>, <span class="number">0x1B</span>, <span class="number">0xAF</span>, <span class="number">0x92</span>, <span class="number">0xBB</span>, <span class="number">0xDD</span>, <span class="number">0xBC</span>, <span class="number">0x7F</span>, <span class="number">0x11</span>, <span class="number">0xD9</span>, <span class="number">0x5C</span>, <span class="number">0x41</span>, <span class="number">0x1F</span>, <span class="number">0x10</span>, <span class="number">0x5A</span>, <span class="number">0xD8</span>,</span><br><span class="line">    <span class="number">0x0A</span>, <span class="number">0xC1</span>, <span class="number">0x31</span>, <span class="number">0x88</span>, <span class="number">0xA5</span>, <span class="number">0xCD</span>, <span class="number">0x7B</span>, <span class="number">0xBD</span>, <span class="number">0x2D</span>, <span class="number">0x74</span>, <span class="number">0xD0</span>, <span class="number">0x12</span>, <span class="number">0xB8</span>, <span class="number">0xE5</span>, <span class="number">0xB4</span>, <span class="number">0xB0</span>,</span><br><span class="line">    <span class="number">0x89</span>, <span class="number">0x69</span>, <span class="number">0x97</span>, <span class="number">0x4A</span>, <span class="number">0x0C</span>, <span class="number">0x96</span>, <span class="number">0x77</span>, <span class="number">0x7E</span>, <span class="number">0x65</span>, <span class="number">0xB9</span>, <span class="number">0xF1</span>, <span class="number">0x09</span>, <span class="number">0xC5</span>, <span class="number">0x6E</span>, <span class="number">0xC6</span>, <span class="number">0x84</span>,</span><br><span class="line">    <span class="number">0x18</span>, <span class="number">0xF0</span>, <span class="number">0x7D</span>, <span class="number">0xEC</span>, <span class="number">0x3A</span>, <span class="number">0xDC</span>, <span class="number">0x4D</span>, <span class="number">0x20</span>, <span class="number">0x79</span>, <span class="number">0xEE</span>, <span class="number">0x5F</span>, <span class="number">0x3E</span>, <span class="number">0xD7</span>, <span class="number">0xCB</span>, <span class="number">0x39</span>, <span class="number">0x48</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sm4.h&quot;</span></span></span><br><span class="line"><span class="comment">//4字节无符号数组转无符号long型</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">four_uCh2uLong</span><span class="params">(u8* in, u32* out)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">*out = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">*out = ((u32)in[i] &lt;&lt; (<span class="number">24</span> - i * <span class="number">8</span>)) ^ *out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无符号long型转4字节无符号数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uLong2four_uCh</span><span class="params">(u32 in, u8* out)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//从32位unsigned long的高位开始取</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">*(out + i) = (u32)(in &gt;&gt; (<span class="number">24</span> - i * <span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左移，保留丢弃位放置尾部</span></span><br><span class="line">u32 <span class="title function_">move</span><span class="params">(u32 data, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">u32 result = <span class="number">0</span>;</span><br><span class="line">result = (data &lt;&lt; length) ^ (data &gt;&gt; (<span class="number">32</span> - length));</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//秘钥处理函数,先使用Sbox进行非线性变化，再将线性变换L置换为L&#x27;</span></span><br><span class="line">u32 <span class="title function_">func_key</span><span class="params">(u32 input)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">u32 ulTmp = <span class="number">0</span>;</span><br><span class="line">u8 ucIndexList[<span class="number">4</span>] = &#123;</span><br><span class="line"> <span class="number">0</span> &#125;;</span><br><span class="line">u8 ucSboxValueList[<span class="number">4</span>] = &#123;</span><br><span class="line"> <span class="number">0</span> &#125;;</span><br><span class="line">uLong2four_uCh(input, ucIndexList);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">ucSboxValueList[i] = TBL_SBOX[ucIndexList[i]];</span><br><span class="line">&#125;</span><br><span class="line">four_uCh2uLong(ucSboxValueList, &amp;ulTmp);</span><br><span class="line">ulTmp = ulTmp ^ move(ulTmp, <span class="number">13</span>) ^ move(ulTmp, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">return</span> ulTmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加解密数据处理函数,先使用Sbox进行非线性变化，再进行线性变换L</span></span><br><span class="line">u32 <span class="title function_">func_data</span><span class="params">(u32 input)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">u32 ulTmp = <span class="number">0</span>;</span><br><span class="line">u8 ucIndexList[<span class="number">4</span>] = &#123;</span><br><span class="line"> <span class="number">0</span> &#125;;</span><br><span class="line">u8 ucSboxValueList[<span class="number">4</span>] = &#123;</span><br><span class="line"> <span class="number">0</span> &#125;;</span><br><span class="line">uLong2four_uCh(input, ucIndexList);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">ucSboxValueList[i] = TBL_SBOX[ucIndexList[i]];</span><br><span class="line">&#125;</span><br><span class="line">four_uCh2uLong(ucSboxValueList, &amp;ulTmp);</span><br><span class="line">ulTmp = ulTmp ^ move(ulTmp, <span class="number">2</span>) ^ move(ulTmp, <span class="number">10</span>) ^ move(ulTmp, <span class="number">18</span>) ^ move(ulTmp, <span class="number">24</span>);</span><br><span class="line"><span class="keyword">return</span> ulTmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加密函数（可以加密任意长度数据，16字节为一次循环，不足部分补0凑齐16字节的整数倍）</span></span><br><span class="line"><span class="comment">//len:数据长度(任意长度数据) key:密钥（16字节） input:输入的原始数据 output:加密后输出数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">encode_fun</span><span class="params">(u8 len, u8* key, u8* input, u8* output)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">u8* p = (u8*)<span class="built_in">malloc</span>(<span class="number">50</span>);      <span class="comment">//定义一个50字节缓存区</span></span><br><span class="line">u32 ulKeyTmpList[<span class="number">4</span>] = &#123;</span><br><span class="line"> <span class="number">0</span> &#125;;   <span class="comment">//存储密钥的u32数据</span></span><br><span class="line">u32 ulKeyList[<span class="number">36</span>] = &#123;</span><br><span class="line"> <span class="number">0</span> &#125;;     <span class="comment">//用于密钥扩展算法与系统参数FK运算后的结果存储</span></span><br><span class="line">u32 ulDataList[<span class="number">36</span>] = &#123;</span><br><span class="line"> <span class="number">0</span> &#125;;    <span class="comment">//用于存放加密数据</span></span><br><span class="line"><span class="comment">/***************************开始生成子秘钥********************************************/</span></span><br><span class="line">four_uCh2uLong(key, &amp;(ulKeyTmpList[<span class="number">0</span>]));</span><br><span class="line">four_uCh2uLong(key + <span class="number">4</span>, &amp;(ulKeyTmpList[<span class="number">1</span>]));</span><br><span class="line">four_uCh2uLong(key + <span class="number">8</span>, &amp;(ulKeyTmpList[<span class="number">2</span>]));</span><br><span class="line">four_uCh2uLong(key + <span class="number">12</span>, &amp;(ulKeyTmpList[<span class="number">3</span>]));</span><br><span class="line">ulKeyList[<span class="number">0</span>] = ulKeyTmpList[<span class="number">0</span>] ^ TBL_SYS_PARAMS[<span class="number">0</span>];</span><br><span class="line">ulKeyList[<span class="number">1</span>] = ulKeyTmpList[<span class="number">1</span>] ^ TBL_SYS_PARAMS[<span class="number">1</span>];</span><br><span class="line">ulKeyList[<span class="number">2</span>] = ulKeyTmpList[<span class="number">2</span>] ^ TBL_SYS_PARAMS[<span class="number">2</span>];</span><br><span class="line">ulKeyList[<span class="number">3</span>] = ulKeyTmpList[<span class="number">3</span>] ^ TBL_SYS_PARAMS[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)             <span class="comment">//32次循环迭代运算</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5-36为32个子秘钥</span></span><br><span class="line">ulKeyList[i + <span class="number">4</span>] = ulKeyList[i] ^ func_key(ulKeyList[i + <span class="number">1</span>] ^ ulKeyList[i + <span class="number">2</span>] ^ ulKeyList[i + <span class="number">3</span>] ^ TBL_FIX_PARAMS[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************************生成32轮32位长子秘钥结束**********************************/</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)        <span class="comment">//将输入数据存放在p缓存区</span></span><br><span class="line">*(p + i) = *(input + i);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span> - len % <span class="number">16</span>; i++)<span class="comment">//将不足16位补0凑齐16的整数倍</span></span><br><span class="line">*(p + len + i) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len / <span class="number">16</span> + ((len % <span class="number">16</span>) ? <span class="number">1</span> : <span class="number">0</span>); j++)  <span class="comment">//进行循环加密,并将加密后数据保存（可以看出此处是以16字节为一次加密，进行循环，即若16字节则进行一次，17字节补0至32字节后进行加密两次，以此类推）</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*开始处理加密数据*/</span></span><br><span class="line">four_uCh2uLong(p + <span class="number">16</span> * j, &amp;(ulDataList[<span class="number">0</span>]));</span><br><span class="line">four_uCh2uLong(p + <span class="number">16</span> * j + <span class="number">4</span>, &amp;(ulDataList[<span class="number">1</span>]));</span><br><span class="line">four_uCh2uLong(p + <span class="number">16</span> * j + <span class="number">8</span>, &amp;(ulDataList[<span class="number">2</span>]));</span><br><span class="line">four_uCh2uLong(p + <span class="number">16</span> * j + <span class="number">12</span>, &amp;(ulDataList[<span class="number">3</span>]));</span><br><span class="line"><span class="comment">//加密</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">ulDataList[i + <span class="number">4</span>] = ulDataList[i] ^ func_data(ulDataList[i + <span class="number">1</span>] ^ ulDataList[i + <span class="number">2</span>] ^ ulDataList[i + <span class="number">3</span>] ^ ulKeyList[i + <span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*将加密后数据输出*/</span></span><br><span class="line">uLong2four_uCh(ulDataList[<span class="number">35</span>], output + <span class="number">16</span> * j);</span><br><span class="line">uLong2four_uCh(ulDataList[<span class="number">34</span>], output + <span class="number">16</span> * j + <span class="number">4</span>);</span><br><span class="line">uLong2four_uCh(ulDataList[<span class="number">33</span>], output + <span class="number">16</span> * j + <span class="number">8</span>);</span><br><span class="line">uLong2four_uCh(ulDataList[<span class="number">32</span>], output + <span class="number">16</span> * j + <span class="number">12</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解密函数（与加密函数基本一致，只是秘钥使用的顺序不同，即把钥匙反着用就是解密）</span></span><br><span class="line"><span class="comment">//len:数据长度 key:密钥 input:输入的加密后数据 output:输出的解密后数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decode_fun</span><span class="params">(u8 len, u8* key, u8* input, u8* output)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">u32 ulKeyTmpList[<span class="number">4</span>] = &#123;</span><br><span class="line"> <span class="number">0</span> &#125;;<span class="comment">//存储密钥的u32数据</span></span><br><span class="line">u32 ulKeyList[<span class="number">36</span>] = &#123;</span><br><span class="line"> <span class="number">0</span> &#125;;  <span class="comment">//用于密钥扩展算法与系统参数FK运算后的结果存储</span></span><br><span class="line">u32 ulDataList[<span class="number">36</span>] = &#123;</span><br><span class="line"> <span class="number">0</span> &#125;; <span class="comment">//用于存放加密数据</span></span><br><span class="line"><span class="comment">/*开始生成子秘钥*/</span></span><br><span class="line">four_uCh2uLong(key, &amp;(ulKeyTmpList[<span class="number">0</span>]));</span><br><span class="line">four_uCh2uLong(key + <span class="number">4</span>, &amp;(ulKeyTmpList[<span class="number">1</span>]));</span><br><span class="line">four_uCh2uLong(key + <span class="number">8</span>, &amp;(ulKeyTmpList[<span class="number">2</span>]));</span><br><span class="line">four_uCh2uLong(key + <span class="number">12</span>, &amp;(ulKeyTmpList[<span class="number">3</span>]));</span><br><span class="line">ulKeyList[<span class="number">0</span>] = ulKeyTmpList[<span class="number">0</span>] ^ TBL_SYS_PARAMS[<span class="number">0</span>];</span><br><span class="line">ulKeyList[<span class="number">1</span>] = ulKeyTmpList[<span class="number">1</span>] ^ TBL_SYS_PARAMS[<span class="number">1</span>];</span><br><span class="line">ulKeyList[<span class="number">2</span>] = ulKeyTmpList[<span class="number">2</span>] ^ TBL_SYS_PARAMS[<span class="number">2</span>];</span><br><span class="line">ulKeyList[<span class="number">3</span>] = ulKeyTmpList[<span class="number">3</span>] ^ TBL_SYS_PARAMS[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)             <span class="comment">//32次循环迭代运算</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5-36为32个子秘钥</span></span><br><span class="line">ulKeyList[i + <span class="number">4</span>] = ulKeyList[i] ^ func_key(ulKeyList[i + <span class="number">1</span>] ^ ulKeyList[i + <span class="number">2</span>] ^ ulKeyList[i + <span class="number">3</span>] ^ TBL_FIX_PARAMS[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*生成32轮32位长子秘钥结束*/</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len / <span class="number">16</span>; j++)  <span class="comment">//进行循环加密,并将加密后数据保存</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*开始处理解密数据*/</span></span><br><span class="line">four_uCh2uLong(input + <span class="number">16</span> * j, &amp;(ulDataList[<span class="number">0</span>]));</span><br><span class="line">four_uCh2uLong(input + <span class="number">16</span> * j + <span class="number">4</span>, &amp;(ulDataList[<span class="number">1</span>]));</span><br><span class="line">four_uCh2uLong(input + <span class="number">16</span> * j + <span class="number">8</span>, &amp;(ulDataList[<span class="number">2</span>]));</span><br><span class="line">four_uCh2uLong(input + <span class="number">16</span> * j + <span class="number">12</span>, &amp;(ulDataList[<span class="number">3</span>]));</span><br><span class="line"><span class="comment">//解密</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">ulDataList[i + <span class="number">4</span>] = ulDataList[i] ^ func_data(ulDataList[i + <span class="number">1</span>] ^ ulDataList[i + <span class="number">2</span>] ^ ulDataList[i + <span class="number">3</span>] ^ ulKeyList[<span class="number">35</span> - i]);<span class="comment">//与加密唯一不同的就是轮密钥的使用顺序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*将解密后数据输出*/</span></span><br><span class="line">uLong2four_uCh(ulDataList[<span class="number">35</span>], output + <span class="number">16</span> * j);</span><br><span class="line">uLong2four_uCh(ulDataList[<span class="number">34</span>], output + <span class="number">16</span> * j + <span class="number">4</span>);</span><br><span class="line">uLong2four_uCh(ulDataList[<span class="number">33</span>], output + <span class="number">16</span> * j + <span class="number">8</span>);</span><br><span class="line">uLong2four_uCh(ulDataList[<span class="number">32</span>], output + <span class="number">16</span> * j + <span class="number">12</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无符号字符数组转16进制打印</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_hex</span><span class="params">(u8* data, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> alTmp[<span class="number">16</span>] = &#123;</span><br><span class="line"> <span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, alTmp[data[i] / <span class="number">16</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, alTmp[data[i] % <span class="number">16</span>]);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*在主函数中实现任意字节加密与解密，并且结果正确*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">u8 i, len;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> encode_Result[<span class="number">32</span>] = &#123;</span><br><span class="line"><span class="number">0xFB</span>, <span class="number">0x97</span>, <span class="number">0x3C</span>, <span class="number">0x3B</span>, <span class="number">0xF1</span>, <span class="number">0x99</span>, <span class="number">0x12</span>, <span class="number">0xDF</span>, <span class="number">0x13</span>, <span class="number">0x30</span>, <span class="number">0xF7</span>, <span class="number">0xD8</span>, <span class="number">0x7F</span>, <span class="number">0xEB</span>, <span class="number">0xA0</span>, <span class="number">0x6C</span>,</span><br><span class="line"><span class="number">0x14</span>, <span class="number">0x5B</span>, <span class="number">0xA6</span>, <span class="number">0x2A</span>, <span class="number">0xA8</span>, <span class="number">0x05</span>, <span class="number">0xA5</span>, <span class="number">0xF3</span>, <span class="number">0x76</span>, <span class="number">0xBE</span>, <span class="number">0xC9</span>, <span class="number">0x01</span>, <span class="number">0xF9</span>, <span class="number">0x36</span>, <span class="number">0x7B</span>, <span class="number">0x46</span>,</span><br><span class="line">&#125;;</span><br><span class="line">u8 decode_Result[<span class="number">50</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">u8 key[] = <span class="string">&quot;NCTF24nctfNCTF24&quot;</span>;</span><br><span class="line"><span class="comment">//u8 Data_plain[18] = &#123; 0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23 &#125;;//定义18字节的原始输入数据（测试用）</span></span><br><span class="line"><span class="comment">//u8 Data_plain[32] = &#123; 0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10 &#125;;//定义32字节的原始输入数据（测试用）</span></span><br><span class="line"></span><br><span class="line">u8 Data_plain[<span class="number">32</span>] = &#123;</span><br><span class="line"><span class="number">0x06</span>, <span class="number">0x75</span>, <span class="number">0x19</span>, <span class="number">0x47</span>, <span class="number">0x16</span>, <span class="number">0x63</span>, <span class="number">0x88</span>, <span class="number">0x7C</span>, <span class="number">0x8B</span>, <span class="number">0x66</span>,</span><br><span class="line">   <span class="number">0x55</span>, <span class="number">0xFF</span>, <span class="number">0x3F</span>, <span class="number">0x7D</span>, <span class="number">0x0D</span>, <span class="number">0x4A</span>, <span class="number">0xF5</span>, <span class="number">0xD2</span>, <span class="number">0x4E</span>, <span class="number">0x38</span>,</span><br><span class="line">   <span class="number">0x3F</span>, <span class="number">0xE9</span>, <span class="number">0xC2</span>, <span class="number">0xDE</span>, <span class="number">0xDB</span>, <span class="number">0x7C</span>, <span class="number">0x7F</span>, <span class="number">0x6F</span>, <span class="number">0x74</span>, <span class="number">0xB1</span>,</span><br><span class="line">   <span class="number">0x1F</span>, <span class="number">0x3C</span> &#125;;<span class="comment">//输入数据，密文或明文</span></span><br><span class="line">len = <span class="number">32</span>;<span class="comment">//长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//len = 16 * (sizeof(Data_plain) / 16) + 16 * ((sizeof(Data_plain) % 16) ? 1 : 0);//得到扩充后的字节数（解密函数会用到）</span></span><br><span class="line"><span class="comment">//encode_fun(sizeof(Data_plain), key, Data_plain, encode_Result);            //数据加密</span></span><br><span class="line"><span class="comment">/*printf(&quot;加密后数据是：\n&quot;);*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*注意：此处解密函数的输入数据长度应为扩展后的数据长度，即必为16的倍数*/</span></span><br><span class="line">decode_fun(len, key, encode_Result, decode_Result); </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *(decode_Result + i));</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行就可以得到flag了</p><h2 id="ezDos"><a href="#ezDos" class="headerlink" title="ezDos"></a>ezDos</h2><p>拿到题目发现是16位的汇编程序，那就是考验汇编能力，这里需要十分细心</p><p>拿到之后先去除花指令，都是一些简单的永真永假跳转，可以随意过掉，这里直接看逻辑</p><p><img src="/1742794559270-ad5bba91-d726-4a7b-86b7-38f52cbbc98c.png"></p><p>通过这里的判断逻辑以及不相等就直接跳飞，可以看出这是判断输入的长度</p><p><img src="/1742794611718-997950f5-7410-4992-b8e3-a8e0d3277a84.png"></p><p>这里不断push再加，可以判断出应该就是一个将1-256数据压入到栈中</p><p><strong><font style="background-color:#E7E9E8;">cx的判断循环的次数</font></strong></p><p><img src="/1742794683627-af7ab3a2-c642-4f8c-9363-bd075f567384.png"></p><p>之后就是把这个取出，这其实就是rc4加密的魔改，这里取出的逻辑是遵循栈的先进后出，所以这里的s初始化就是256-0，和s盒的初始化是相反</p><p><img src="/1742794822556-9397c075-e7e9-47b4-b980-e569f3ee82cc.png"></p><p>这里其实可以去看这个数据区发现有字符串，其实就是密钥，这里除余这个字符串的长度可以判断除这里就是密钥的初始操作</p><p><img src="/1742794946363-ea55dd3f-2cda-46dc-a041-8cd3e22d95d6.png"></p><p>这里因为它调用的函数对返回地址进行了改变，所以需要pop，这里的逻辑就是对密钥进行了位移操作，然后前面除的数字再去数组中找key</p><p><img src="/1742795446720-e214a0a1-cd7e-4118-bd4f-f80a640b0d01.png"></p><p>and就是除余256，所以这个很容易看出是rc4</p><p><img src="/1742795901264-cd500c4e-fff9-491a-bf3e-c7f6bbe45bdb.png"></p><p>这个也是魔改点</p><p>所以这里的魔改点就是s盒倒序，这个key的位移操作，以及这个s盒值加1</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环左移3位</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">rol3</span><span class="params">(<span class="type">uint8_t</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((b &lt;&lt; <span class="number">3</span>) | (b &gt;&gt; <span class="number">5</span>)) &amp; <span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KSA过程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KSA</span><span class="params">(<span class="type">uint8_t</span>* S, <span class="type">uint8_t</span>* key, <span class="type">uint32_t</span> key_len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 倒序初始化</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        S[i] = <span class="number">255</span> - i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        j = (j + S[i] + key[i % key_len]) % <span class="number">256</span>;</span><br><span class="line">        tmp = S[i];</span><br><span class="line">        S[i] = S[j];</span><br><span class="line">        S[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PRGA过程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PRGA</span><span class="params">(<span class="type">uint8_t</span>* S, <span class="type">uint8_t</span>* keystream, <span class="type">uint32_t</span> length)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, t;</span><br><span class="line">    <span class="type">uint8_t</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> k = <span class="number">0</span>; k &lt; length; k++) &#123;</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">        j = (j + S[i]) % <span class="number">256</span>;</span><br><span class="line">        tmp = S[i];</span><br><span class="line">        S[i] = S[j];</span><br><span class="line">        S[j] = tmp;</span><br><span class="line">        t = (S[i] + S[j]) % <span class="number">256</span>;</span><br><span class="line">        keystream[k] = (S[t] + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 密钥</span></span><br><span class="line">    <span class="type">char</span> key_str[] = <span class="string">&quot;NCTf2024nctF&quot;</span>;</span><br><span class="line">    <span class="type">uint32_t</span> key_len = <span class="keyword">sizeof</span>(key_str) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint8_t</span> key[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; key_len; i++) &#123;</span><br><span class="line">        key[i] = rol3((<span class="type">uint8_t</span>)key_str[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 S 盒</span></span><br><span class="line">    <span class="type">uint8_t</span> S[<span class="number">256</span>];</span><br><span class="line">    KSA(S, key, key_len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 密文</span></span><br><span class="line">    <span class="type">uint8_t</span> ciphertext[] = &#123;</span><br><span class="line">        <span class="number">0x7C</span>, <span class="number">0x3E</span>, <span class="number">0x0D</span>, <span class="number">0x3C</span>, <span class="number">0x88</span>, <span class="number">0x54</span>, <span class="number">0x83</span>, <span class="number">0x0E</span>, <span class="number">0x3B</span>, <span class="number">0xB8</span>, <span class="number">0x99</span>, <span class="number">0x1B</span>, <span class="number">0x9B</span>, <span class="number">0xE5</span>, <span class="number">0x23</span>, <span class="number">0x43</span>, <span class="number">0xC5</span>, <span class="number">0x80</span>, <span class="number">0x45</span>,</span><br><span class="line">        <span class="number">0x5B</span>, <span class="number">0x9A</span>, <span class="number">0x29</span>, <span class="number">0x24</span>, <span class="number">0x38</span>, <span class="number">0xA9</span>, <span class="number">0x5C</span>, <span class="number">0xCB</span>, <span class="number">0x7A</span>, <span class="number">0xE5</span>, <span class="number">0x93</span>, <span class="number">0x73</span>, <span class="number">0x0E</span>, <span class="number">0x70</span>, <span class="number">0x6D</span>, <span class="number">0x7C</span>, <span class="number">0x31</span>, <span class="number">0x2B</span>, <span class="number">0x8C</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">uint32_t</span> ciphertext_len = <span class="keyword">sizeof</span>(ciphertext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成密钥流</span></span><br><span class="line">    <span class="type">uint8_t</span> keystream[<span class="number">38</span>];</span><br><span class="line">    PRGA(S, keystream, ciphertext_len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密</span></span><br><span class="line">    <span class="type">uint8_t</span> plaintext[<span class="number">38</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; ciphertext_len; i++) &#123;</span><br><span class="line">        plaintext[i] = ciphertext[i] ^ keystream[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Flag: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; ciphertext_len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (plaintext[i] &gt;= <span class="number">32</span> &amp;&amp; plaintext[i] &lt;= <span class="number">126</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, plaintext[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\\x%02X&quot;</span>, plaintext[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;X1c@dM1n1$t&lt;/p&gt;
&lt;p&gt;7d53ecd36a43d3d2&lt;/p&gt;
&lt;p&gt;37e7dd633dcf8497&lt;/p&gt;
&lt;p&gt;409EEC86B884A58B7E8A64E21AD3B8BB&lt;/p&gt;
&lt;h2 id=&quot;x1login&quot;&gt;&lt;a href=&quot;#x1logi</summary>
      
    
    
    
    <category term="技术" scheme="https://jayuyu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>春秋杯2025</title>
    <link href="https://jayuyu.github.io/posts/4f01/"/>
    <id>https://jayuyu.github.io/posts/4f01/</id>
    <published>2025-01-21T16:00:00.000Z</published>
    <updated>2025-03-25T15:19:39.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iiZJM">KoOh</h2><p><img src="/../image/1737127921565-d071b9c0-0e18-40ba-98ff-490f7327da61.png"></p><p>这道题如果先去找主函数的方法，来到了这里，是一个base64加密，点开那个参数<img src="/../image/1737127980725-7b64051b-c673-42da-8c22-dbcf7bc45658.png"></p><p>应该是base64加密变表</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">str1 = <span class="string">&quot;zMXHz3TMywTLx2zSywCHzMfRzv9MBgfNiwzHA2vFzMXHzYeHiseHisf9&quot;</span></span><br><span class="line"></span><br><span class="line">string1 = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/&quot;</span></span><br><span class="line">string2 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (base64.b64decode(str1.translate(<span class="built_in">str</span>.maketrans(string1,string2))))</span><br><span class="line"><span class="comment">#flag&#123;fake_flag!fake_flag!fake_flag!!!!!!!&#125;</span></span><br></pre></td></tr></table></figure><p>错误的flag，此时我们观察上图发现下面有一些字符串，看看交叉引用</p><p>发现有一大串代码是处于爆红状态，发现有花指令，这个时候反编译</p><p><img src="/../image/1737128271873-d18cfe27-9944-4037-abd3-5866cb180243.png"></p><p><img src="/../image/1737128207838-c4c711db-c645-44ed-8597-aa44e23a09b4.png"></p><p>此时看到这个hook，很明显是先解密那串很奇怪的字符串，解密之后是ida.exe,ollydbg等等，拍进程快照然后判断是不是在运行这些进程来反调试</p><p>这个时候如果发现在调试的化，就会退出，这里的方法就是将eax的值设置为0，其实我是静态看的。</p><p>之后发现了rc4的变种</p><p><img src="/../image/1737128428395-2b48b3a6-ff5f-4a53-ae92-67ee7f6900ee.png"></p><p>这里其实很明显的rc4，交exp</p><p>注意两个点：<br>1.这里的rc4加密魔改点是最后的异或变成了-</p><p>2.密钥被替代了</p><p>当我去跟踪这些散落的代码的时候，发现他们的最开始引用都是在Tlscallback函数里面，也就是说都先于主函数进行</p><p><img src="/../image/1737128680313-5a0d7bcc-5a04-48e0-a797-285fab8d5a42.png"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">RC4初始化函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rc4_init</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* s, <span class="type">unsigned</span> <span class="type">char</span>* key, <span class="type">unsigned</span> <span class="type">long</span> Len_k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> k[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        s[i] = i;</span><br><span class="line">        k[i] = key[i % Len_k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        j = (j + s[i] + k[i]) % <span class="number">256</span>;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">RC4加解密函数</span></span><br><span class="line"><span class="comment">unsigned char* Data     加解密的数据</span></span><br><span class="line"><span class="comment">unsigned long Len_D     加解密数据的长度</span></span><br><span class="line"><span class="comment">unsigned char* key      密钥</span></span><br><span class="line"><span class="comment">unsigned long Len_k     密钥长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rc4_crypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* Data, <span class="type">unsigned</span> <span class="type">long</span> Len_D, <span class="type">unsigned</span> <span class="type">char</span>* key, <span class="type">unsigned</span> <span class="type">long</span> Len_k)</span> <span class="comment">//加解密</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> s[<span class="number">256</span>];</span><br><span class="line">    rc4_init(s, key, Len_k);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; Len_D; k++) &#123;</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">        j = (j + s[i]) % <span class="number">256</span>;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = tmp;</span><br><span class="line">        t = (s[i] + s[j])%<span class="number">256</span> ;</span><br><span class="line">        Data[k] = (<span class="type">unsigned</span> <span class="type">char</span>)((<span class="type">int</span>)Data[k] +(<span class="type">int</span>)s[t]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//字符串密钥</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> key[] = <span class="string">&quot;DDDDAAAASSSS&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> key_len = <span class="keyword">sizeof</span>(key)<span class="number">-1</span> ;</span><br><span class="line">    <span class="comment">//数组密钥</span></span><br><span class="line">    <span class="comment">//unsigned char key[] = &#123;&#125;;</span></span><br><span class="line">    <span class="comment">//unsigned long key_len = sizeof(key);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加解密数据</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[] = &#123; <span class="number">0x18</span>, <span class="number">0x9C</span>, <span class="number">0x47</span>, <span class="number">0x3D</span>, <span class="number">0x3B</span>, <span class="number">0xE1</span>, <span class="number">0x29</span>, <span class="number">0x27</span>, <span class="number">0x9F</span>, <span class="number">0x34</span>,</span><br><span class="line">                            <span class="number">0x83</span>, <span class="number">0xD5</span>, <span class="number">0xED</span>, <span class="number">0xB5</span>, <span class="number">0x6E</span>, <span class="number">0x59</span>, <span class="number">0x7F</span>, <span class="number">0xDE</span>, <span class="number">0x47</span>, <span class="number">0xD7</span>,</span><br><span class="line">                            <span class="number">0x65</span>, <span class="number">0x3F</span>, <span class="number">0x7A</span>, <span class="number">0x33</span>, <span class="number">0x5B</span>, <span class="number">0x64</span>, <span class="number">0xB6</span>, <span class="number">0xFA</span>, <span class="number">0x94</span>, <span class="number">0x55</span>,</span><br><span class="line">                            <span class="number">0x87</span>, <span class="number">0x42</span>, <span class="number">0x20</span>, <span class="number">0x06</span>, <span class="number">0x0C</span>, <span class="number">0x69</span>, <span class="number">0xFE</span>, <span class="number">0x72</span>, <span class="number">0xA9</span>, <span class="number">0xE4</span>,</span><br><span class="line">                            <span class="number">0xD1</span>, <span class="number">0x7C</span></span><br><span class="line">                            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加解密</span></span><br><span class="line">    rc4_crypt(data, <span class="keyword">sizeof</span>(data), key, key_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(data); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//zstuctf&#123;xXx_team_Is_GooD</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="tUfjA">ez_RE</h2><p><img src="/../image/1737207250507-82f8dc23-ed3b-47ff-87d6-fafcd6367159.png"></p><p>进来发现了一个随机数种子，跟md5有关，接着是一个异或随机数，这里点开生成种子看看</p><p><img src="/../image/1737207309017-dc42ecf5-c400-45ba-966e-9ba2bb449469.png"></p><p>这段代码的具体意思是将函数的前1024个字节当种子，这里可能操作系统不同的化，编译器不同，电脑不同</p><p> 代码中利用了 <code>custom_md5_init</code> 函数的<strong>内存布局</strong>作为加密输入的一部分。所谓“内存布局”，是指函数在运行时被加载到内存后，具体的机器指令、数据和偏移地址的排列形式。由于内存布局会受到编译器、操作系统、以及某些安全机制（例如地址空间随机化 ASLR）的影响，可能在不同运行环境下表现出不同的动态特性。  </p><p>那怎么办，可以试试爆破种子。但是必须在Linux环境去爆破，</p><p>具体Linux命令是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ac.cpp</span><br><span class="line">gcc ac.cpp -o ae</span><br><span class="line">如果是c++</span><br><span class="line">g++ ac.cpp -o ae</span><br><span class="line">./ae</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Enc[] =</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x5C</span>, <span class="number">0x76</span>, <span class="number">0x4A</span>, <span class="number">0x78</span>, <span class="number">0x15</span>, <span class="number">0x62</span>, <span class="number">0x05</span>, <span class="number">0x7C</span>, <span class="number">0x6B</span>, <span class="number">0x21</span>,</span><br><span class="line"><span class="number">0x40</span>, <span class="number">0x66</span>, <span class="number">0x5B</span>, <span class="number">0x1A</span>, <span class="number">0x48</span>, <span class="number">0x7A</span>, <span class="number">0x1E</span>, <span class="number">0x46</span>, <span class="number">0x7F</span>, <span class="number">0x28</span>,</span><br><span class="line"><span class="number">0x02</span>, <span class="number">0x75</span>, <span class="number">0x68</span>, <span class="number">0x2A</span>, <span class="number">0x34</span>, <span class="number">0x0C</span>, <span class="number">0x4B</span>, <span class="number">0x1D</span>, <span class="number">0x3D</span>, <span class="number">0x2E</span>,</span><br><span class="line"><span class="number">0x6B</span>, <span class="number">0x7A</span>, <span class="number">0x17</span>, <span class="number">0x45</span>, <span class="number">0x07</span>, <span class="number">0x75</span>, <span class="number">0x47</span>, <span class="number">0x27</span>, <span class="number">0x39</span>, <span class="number">0x78</span>,</span><br><span class="line"><span class="number">0x61</span>, <span class="number">0x0B</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Crack!!!</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">0xB0000000</span>;i&lt;<span class="number">0xC0000000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">srand</span>(i);</span><br><span class="line"><span class="type">int</span> randlist[<span class="number">42</span>]&#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">42</span>;j++)</span><br><span class="line">randlist[j]=<span class="built_in">rand</span>()%<span class="number">127</span>;</span><br><span class="line"><span class="keyword">if</span>(randlist[<span class="number">0</span>] == (<span class="number">0x5C</span>^<span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">&amp;&amp; randlist[<span class="number">1</span>] == (<span class="number">0x76</span>^<span class="string">&#x27;l&#x27;</span>)</span><br><span class="line">&amp;&amp; randlist[<span class="number">2</span>] == (<span class="number">0x4A</span>^<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">&amp;&amp; randlist[<span class="number">3</span>] == (<span class="number">0x78</span>^<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">&amp;&amp; randlist[<span class="number">4</span>] == (<span class="number">0x15</span>^<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">std::cout&lt;&lt;i&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">std::cin.<span class="built_in">get</span>();</span><br><span class="line"><span class="comment">//output: 3021285795</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个爆破范围不是很确定，应该可以慢慢试，就小32位，不是很大，</p><p>这里注意，因为这是linux文件，他们的c库不同，环境不同，所以exp必须在linux环境中跑</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;b799eb3a-59ee-4b3b-b49d-39080fc23e99&#125;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;iiZJM&quot;&gt;KoOh&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/../image/1737127921565-d071b9c0-0e18-40ba-98ff-490f7327da61.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;这道题如果先去找主函数的方法，来到了这里，是一个bas</summary>
      
    
    
    
    <category term="技术" scheme="https://jayuyu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
</feed>
