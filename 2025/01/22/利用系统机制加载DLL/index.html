<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="如果创建的是一个局部钩子，进程里面的钩子函数就会被调用，如果想创建远程钩子，系统就必须把这个钩子函数插入到其他地址空间里面去，所以必须保证钩子函数在一个动态链接库里面 一：什么是钩子链表系统提供多种不同类型的钩子用于处理不同的消息。在某一时刻可能有多个进程安装了相同类型的钩子，即同一种钩子有多个不同的钩子处理函数。这多个不同的钩子处理函数的指针构成了钩子链表，由操作系统维护。当某种类型的消息发生时">
<meta property="og:type" content="article">
<meta property="og:title" content="我的第一篇博客">
<meta property="og:url" content="http://example.com/2025/01/22/%E5%88%A9%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9C%BA%E5%88%B6%E5%8A%A0%E8%BD%BDDLL/index.html">
<meta property="og:site_name" content="Reverse">
<meta property="og:description" content="如果创建的是一个局部钩子，进程里面的钩子函数就会被调用，如果想创建远程钩子，系统就必须把这个钩子函数插入到其他地址空间里面去，所以必须保证钩子函数在一个动态链接库里面 一：什么是钩子链表系统提供多种不同类型的钩子用于处理不同的消息。在某一时刻可能有多个进程安装了相同类型的钩子，即同一种钩子有多个不同的钩子处理函数。这多个不同的钩子处理函数的指针构成了钩子链表，由操作系统维护。当某种类型的消息发生时">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpeg/48373702/1732082057407-79ac0d81-a0c1-4f65-894d-ae6f6d25ffdb.jpeg">
<meta property="article:published_time" content="2025-01-21T16:00:00.000Z">
<meta property="article:modified_time" content="2025-01-22T06:24:13.231Z">
<meta property="article:author" content="jayuyu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2024/jpeg/48373702/1732082057407-79ac0d81-a0c1-4f65-894d-ae6f6d25ffdb.jpeg">

<link rel="canonical" href="http://example.com/2025/01/22/%E5%88%A9%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9C%BA%E5%88%B6%E5%8A%A0%E8%BD%BDDLL/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>我的第一篇博客 | Reverse</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Reverse" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Reverse</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-calendar fa-fw"></i>分类</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/22/%E5%88%A9%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9C%BA%E5%88%B6%E5%8A%A0%E8%BD%BDDLL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="jayuyu">
      <meta itemprop="description" content="To the sea of success">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Reverse">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          我的第一篇博客
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-01-22 00:00:00 / 修改时间：14:24:13" itemprop="dateCreated datePublished" datetime="2025-01-22T00:00:00+08:00">2025-01-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B3%A8%E5%85%A5/" itemprop="url" rel="index"><span itemprop="name">注入</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>如果创建的是一个局部钩子，进程里面的钩子函数就会被调用，如果想创建远程钩子，系统就必须把这个钩子函数插入到其他地址空间里面去，所以必须保证钩子函数在一个动态链接库里面</p>
<h1 id="一：什么是钩子链表"><a href="#一：什么是钩子链表" class="headerlink" title="一：什么是钩子链表"></a>一：什么是钩子链表</h1><p><font style="color:rgb(51, 51, 51);">系统提供多种不同类型的钩子用于处理不同的消息。在某一时刻可能有多个进程安装了相同类型的钩子，即</font><strong><font style="color:rgb(51, 51, 51);">同一种钩子有多个不同的钩子处理函数</font></strong><font style="color:rgb(51, 51, 51);">。这多个不同的钩子处理函数的指针构成了钩子链表，由操作系统维护。当某种类型的消息发生时系统向该类型的钩子链表的第一个函数发送该消息，在第一函数处理完该消息后由该函数向链表中的下一个函数传递消息，依次向下。如果链中某个函数没有向下传送该消息，那么链表中后面的函数将得不到此消息。最近安装的钩子放在链的开始，而最早安装的钩子放在最后，也就是后加入的先获得控制权。</font></p>
<h3 id="FpPqr"><font style="color:rgb(51, 51, 51);">二：回调函数</font></h3>
# 二：回调函数

<p>感觉使用中用起来与普通函数差不多，只不过这种回调函数与函数指针相关，比普通函数更高效，以及后面需要用，这里就介绍一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*Callback)</span><span class="params">(<span class="type">int</span>)</span>;<span class="comment">//申明这个回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printsum</span><span class="params">(<span class="type">int</span> result)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, Callback callback)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sum = a + b;</span><br><span class="line">	callback(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">	add(a, b, printsum);<span class="comment">//可以理解为传入的是函数的地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三-SetWindowsHookEx-消息钩子技术"><a href="#三-SetWindowsHookEx-消息钩子技术" class="headerlink" title="三.SetWindowsHookEx 消息钩子技术"></a>三.SetWindowsHookEx 消息钩子技术</h1><h3 id="iTL1E">三.SetWindowsHookEx 消息钩子技术</h3>
[https://blog.csdn.net/weixin_42887343/article/details/115209343](https://blog.csdn.net/weixin_42887343/article/details/115209343)

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31967569/article/details/90175812">https://blog.csdn.net/qq_31967569&#x2F;article&#x2F;details&#x2F;90175812</a>这个文章写得很好，介绍了<strong>钩子</strong>的定义，通俗易懂</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SetWindowsHookEx函数可以把应用程序定义的钩子函数安装到系统中。</span><br><span class="line">    HHOOK <span class="title function_">SetWindowsHookEx</span><span class="params">(</span></span><br><span class="line"><span class="params">      <span class="type">int</span> idHook ;   <span class="comment">// 指定钩子的类型</span></span></span><br><span class="line"><span class="params">      HOOKPROC lpfn; <span class="comment">//钩子函数的地址。如果是远程钩子，钩子函数必须放在一个DLL中。</span></span></span><br><span class="line"><span class="params">      HINSTANCE hMod; <span class="comment">// 钩子函数所在的DLL的实例句柄。局部的钩子，该参数为NULL。</span></span></span><br><span class="line"><span class="params">      DWORD  dwThreadID; <span class="comment">//指定要为哪个线程安装钩子。若该值为0被解释成系统范围内的。</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/48373702/1732082057407-79ac0d81-a0c1-4f65-894d-ae6f6d25ffdb.jpeg" alt="画板"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HHOOK hHook;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 钩子函数</span></span><br><span class="line"><span class="comment">// 1. 什么是 LRESULT？</span></span><br><span class="line"><span class="comment">// 定义：LRESULT 是一个 32 位或 64 位的整数类型（取决于系统架构），通常用来表示钩子或窗口消息处理函数的返回值。</span></span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK <span class="title function_">KeyboardProc</span><span class="params">(<span class="type">int</span> nCode, WPARAM wParam, LPARAM lParam)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nCode &gt;= <span class="number">0</span> &amp;&amp; wParam == WM_KEYDOWN) &#123;</span><br><span class="line">        KBDLLHOOKSTRUCT *pKey = (KBDLLHOOKSTRUCT *)lParam;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Key Pressed: %d\n&quot;</span>, pKey-&gt;vkCode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CallNextHookEx(hHook, nCode, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// LRESULT CALLBACK lpfn(int code, WPARAM wParam, LPARAM lParam) &#123;</span></span><br><span class="line"><span class="comment">//     return CallNextHookEx(g_hHook, code, wParam, lParam);</span></span><br><span class="line"><span class="comment">// &#125;这里的回调函数就是什么都没有做，直接将当前信息传递到钩子链的下一个钩子</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置全局键盘钩子</span></span><br><span class="line">    HINSTANCE hInstance = GetModuleHandle(<span class="literal">NULL</span>); <span class="comment">// 当前模块句柄</span></span><br><span class="line">    hHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardProc, hInstance, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hHook) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to install hook! Error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hook installed. Press any key to see the output.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息循环</span></span><br><span class="line">    MSG msg;</span><br><span class="line">    <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line">        DispatchMessage(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卸载钩子</span></span><br><span class="line">    UnhookWindowsHookEx(hHook);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>idHook</code>：<code>WH_KEYBOARD_LL</code>，拦截全局键盘事件。</li>
<li><code>lpfn</code>：<code>KeyboardProc</code>，用于处理键盘事件的钩子函数。</li>
<li><code>hMod</code>：<code>hInstance</code>，当前模块句柄。</li>
<li><code>dwThreadId</code>：<code>0</code>，表示全局钩子，<font style="color:rgb(77, 77, 77);">钩子所监视的线程的线程号，可通过GetCurrentThreadId()获得线程号。对于全局钩子，该参数为NULL(或0)</font></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">KeyboardProc</span><span class="params">(<span class="type">int</span> nCode, WPARAM wParam, LPARAM lParam)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        KBDLLHOOKSTRUCT *p = (KBDLLHOOKSTRUCT *)lParam;</span><br><span class="line">        <span class="keyword">switch</span>(wParam) &#123;</span><br><span class="line">            <span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">                <span class="comment">// 按键按下事件</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WM_KEYUP:</span><br><span class="line">                <span class="comment">// 按键释放事件</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 其他事件...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CallNextHookEx(<span class="literal">NULL</span>, nCode, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BBECU">1.idhook</h4>


<p>指示欲被挂钩处理的过程类型，也就是要安装的hook类型</p>
<p><strong>WH_MSGFILTER(-1)</strong>：安装一个挂钩处理过程,以监视由对话框、消息框、菜单条、或滚动条中的输入事件引发的消息.详情参见MessageProc挂钩处理过程.</p>
<p><strong>WH_JOURNALRECORD(0</strong>)：安装一个挂钩处理过程,对寄送至系统消息队列的输入消息进行纪录.详情参见JournalRecordProc挂钩处理过程.</p>
<p><strong>WH_JOURNALPLAYBACK(1</strong>)：安装一个挂钩处理过程,对此前由WH_JOURNALRECORD 挂钩处理过程纪录的消息进行寄送.详情参见 JournalPlaybackProc挂钩处理过程.</p>
<p><strong>WH_KEYBOARD(2)</strong>：安装一个挂钩处理过程对击键消息进行监视. 详情参见KeyboardProc挂钩处理过程.</p>
<p><strong>WH_GETMESSAGE(3</strong>):安装一个挂钩处理过程对寄送至消息队列的消息进行监视,详情参见 GetMsgProc 挂钩处理过程.</p>
<p><strong>WH_CALLWNDPROC(4)</strong>: 安装一个挂钩处理过程,在系统将消息发送至目标窗口处理过程之前,对该消息进行监视,详情参见CallWndProc挂钩处理过程.</p>
<p>**WH_CBT(5) **：安装一个挂钩处理过程,接受对CBT应用程序有用的消息 ,详情参见 CBTProc 挂钩处理过程.</p>
<p><strong>WH_SYSMSGFILTER(6)</strong>：安装一个挂钩处理过程,以监视由对话框、消息框、菜单条、或滚动条中的输入事件引发的消息.这个挂钩处理过程对系统中所有应用程序的这类消息都进行监视.详情参见 SysMsgProc挂钩处理过程.</p>
<p><strong>WH_MOUSE(7)</strong>：安装一个挂钩处理过程,对鼠标消息进行监视. 详情参见 MouseProc挂钩处理过程.</p>
<p><strong>WH_DEBUG(9)</strong>：安装一个挂钩处理过程以便对其他挂钩处理过程进行调试, 详情参见DebugProc挂钩处理过程.</p>
<p><strong>WH_SHELL(10)</strong>：安装一个挂钩处理过程以接受对外壳应用程序有用的通知, 详情参见 ShellProc挂钩处理过程.</p>
<p><strong>WH_FOREGROUNDIDLE(11)</strong>：安装一个挂钩处理过程,该挂钩处理过程当应用程序的前台线程即将进入空闲状态时被调用,它有助于在空闲时间内执行低优先级的任务.</p>
<p><strong>WH_CALLWNDPROCRET(12)</strong>：安装一个挂钩处理过程,它对已被目标窗口处理过程处理过了的消息进行监视,详情参见 CallWndRetProc 挂钩处理过程.</p>
<p><strong>WH_KEYBOARD_LL(13)</strong>：此挂钩只能在Windows NT中被安装,用来对底层的键盘输入事件进行监视.详情参见LowLevelKeyboardProc挂钩处理过程.</p>
<p><strong>WH_MOUSE_LL(14)</strong>：此挂钩只能在Windows NT中被安装,用来对底层的鼠标输入事件进行监视.详情参见LowLevelMouseProc挂钩处理过程.</p>
<h4 id="Aq1tS">2.HOOKPRC lpfn</h4>
钩子类型对应的一个钩子函数（回调函数）



<h4 id="xXZTS">3.跨进程的钩子举例</h4>
这里刚刚说了，如果想创建一个远程钩子，必须把钩子函数放在一个DLL里面

<p><font style="color:rgb(77, 77, 77);">如果是全局钩子或者跨进程钩子，钩子的回调函数需要写在</font><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;.dll&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);">动态链接库文件中，在使用</font><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;SetWindowsHookEx&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);">函数为进程挂载钩子后，被挂载钩子的进程会去加载内存中的</font><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;.dll&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);">文件，这时</font><code>&lt;font style=&quot;color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);&quot;&gt;.dll&lt;/font&gt;</code><font style="color:rgb(77, 77, 77);">文件中的函数可以共享该进程中的所有资源（dll注入原理）</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_API __declspec(dllexport)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> MY_API HOOKPROC <span class="title function_">getDllHookProc</span><span class="params">(VOID)</span>;</span><br><span class="line"></span><br><span class="line">BOOL APIENTRY <span class="title function_">DllMain</span><span class="params">(HMODULE hModule,</span></span><br><span class="line"><span class="params">	DWORD  ul_reason_for_call,</span></span><br><span class="line"><span class="params">	LPVOID lpReserved</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_ATTACH: </span><br><span class="line">	<span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">	<span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRESULT CALLBACK <span class="title function_">HookProc</span><span class="params">(<span class="type">int</span> nCode, WPARAM wParam, LPARAM lParam)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 所有小于零的是系统消息不做处理如果不放行系统消息会卡死</span></span><br><span class="line">	<span class="keyword">if</span> (nCode &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;nCode:&quot;</span> &lt;&lt; nCode &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		return 1;</span></span><br><span class="line"><span class="comment">		如果返回一个非零的数则该消息无法被捕获</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 调用下一个钩子一定要调用下一个钩子否则会卡死</span></span><br><span class="line">	<span class="keyword">return</span> CallNextHookEx(<span class="literal">NULL</span>, nCode, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HOOKPROC <span class="title function_">getDllHookProc</span><span class="params">(VOID)</span> &#123;</span><br><span class="line">	<span class="comment">// 返回钩子回调函数</span></span><br><span class="line">	<span class="keyword">return</span> HookProc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HOOKPROC</span><span class="params">(*func)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	HINSTANCE hDll; <span class="comment">//DLL句柄</span></span><br><span class="line">	<span class="comment">// 加载dll</span></span><br><span class="line">	hDll = LoadLibrary(<span class="string">L&quot;testDll.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hDll != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 这里通过窗口标题获取窗口句柄，注意FindWindow只能获取顶级窗口</span></span><br><span class="line">		HWND hwnd = FindWindow(<span class="literal">NULL</span>, <span class="string">L&quot;记事本&quot;</span>);</span><br><span class="line">		<span class="comment">// 获取钩子回调函数</span></span><br><span class="line">		func proc = (func)GetProcAddress(hDll, <span class="string">&quot;getDllHookProc&quot;</span>);</span><br><span class="line">		<span class="comment">// 安装钩子</span></span><br><span class="line">		HHOOK hook = SetWindowsHookEx(WH_KEYBOARD, proc(), hDll, </span><br><span class="line">						GetWindowThreadProcessId(hwnd, <span class="literal">NULL</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 一定要有消息循环不然消息会卡死</span></span><br><span class="line">		MSG msg;</span><br><span class="line">		<span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">			TranslateMessage(&amp;msg);</span><br><span class="line">			DispatchMessage(&amp;msg);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 卸载钩子</span></span><br><span class="line">		UnhookWindowsHookEx(hook);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="HGoaK">函数声明</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BOOL APIENTRY DllMain( HMODULE hModule,</span><br><span class="line">                       DWORD  ul_reason_for_call,</span><br><span class="line">                       LPVOID lpReserved )</span><br></pre></td></tr></table></figure>

<ol>
<li><code>**BOOL**</code><ul>
<li>返回值类型，表示函数执行是否成功。</li>
<li>返回 <code>TRUE</code> 表示成功，<code>FALSE</code> 表示失败。</li>
</ul>
</li>
<li><code>**APIENTRY**</code><ul>
<li>表示这是一个 Windows API 的入口函数，通常是一个宏定义，用来标识调用约定（如 <code>__stdcall</code>）。</li>
</ul>
</li>
<li><code>**DllMain**</code><ul>
<li>DLL 的主入口函数，系统在加载、卸载或线程附加&#x2F;分离时调用此函数。</li>
</ul>
</li>
<li><strong>参数解析</strong>：<ul>
<li><code>**HMODULE hModule**</code>：<ul>
<li>DLL 的模块句柄。</li>
<li>用于标识这个 DLL 实例，可以用于后续操作（如加载资源）。</li>
</ul>
</li>
<li><code>**DWORD ul_reason_for_call**</code>：<ul>
<li>调用的原因，指明了 DLL 入口函数被触发的场景。可能值包括：<ul>
<li><code>**DLL_PROCESS_ATTACH**</code>：进程加载此 DLL 时触发。</li>
<li><code>**DLL_THREAD_ATTACH**</code>：新线程创建并加载此 DLL 时触发。</li>
<li><code>**DLL_THREAD_DETACH**</code>：线程结束并卸载此 DLL 时触发。</li>
<li><code>**DLL_PROCESS_DETACH**</code>：进程卸载此 DLL 时触发。</li>
</ul>
</li>
</ul>
</li>
<li><code>**LPVOID lpReserved**</code>：<ul>
<li>保留字段。</li>
<li>如果 <code>ul_reason_for_call</code> 是 <code>DLL_PROCESS_ATTACH</code>，<code>lpReserved</code> 为 <code>NULL</code> 表示显式加载，为非 NULL 表示隐式加载。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="mEiiQ">函数主体</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">switch (ul_reason_for_call)</span><br></pre></td></tr></table></figure>

<ul>
<li>检查触发 <code>DllMain</code> 的原因，根据不同的值执行相应的逻辑。</li>
</ul>
<hr>
<h5 id="POceb">1. 处理 `DLL_PROCESS_ATTACH`</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">case DLL_PROCESS_ATTACH:</span><br><span class="line">    MessageBoxA(NULL, &quot;你被HOOK了&quot;, &quot;YunShu&quot;, MB_OK);</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>**DLL_PROCESS_ATTACH**</code>：<ul>
<li>表示某个进程加载了这个 DLL。</li>
<li>这是初始化代码的主要位置，通常在这里设置全局资源、初始化钩子、配置等。</li>
</ul>
</li>
<li><code>**MessageBoxA**</code>：<ul>
<li>弹出一个消息框，表示 DLL 被加载。</li>
<li>参数含义：<ul>
<li><code>**NULL**</code>：消息框的父窗口句柄，<code>NULL</code> 表示没有父窗口。</li>
<li><code>**&quot;你被HOOK了&quot;**</code>：消息内容。</li>
<li><code>**&quot;YunShu&quot;**</code>：消息框标题。</li>
<li><code>**MB_OK**</code>：消息框类型，表示只有一个“确定”按钮。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>处理 <code>DLL_THREAD_ATTACH</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">case DLL_THREAD_ATTACH:</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>**DLL_THREAD_ATTACH**</code>：<ul>
<li>表示有线程被创建并加载了此 DLL。</li>
<li>通常这里可以进行每个线程的初始化操作。</li>
<li><strong>当前没有任何操作，直接跳过。</strong></li>
</ul>
</li>
</ul>
<hr>
<h5 id="iveVr">3. 处理 `DLL_THREAD_DETACH`</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">case DLL_THREAD_DETACH:</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>**DLL_THREAD_DETACH**</code>：<ul>
<li>表示有线程即将结束并从此 DLL 卸载。</li>
<li>这里可以清理线程相关的资源。</li>
<li><strong>当前没有任何操作，直接跳过。</strong></li>
</ul>
</li>
</ul>
<hr>
<h5 id="uRNZT">4. 处理 `DLL_PROCESS_DETACH`</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">case DLL_PROCESS_DETACH:</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>**DLL_PROCESS_DETACH**</code>：<ul>
<li>表示进程即将卸载此 DLL。</li>
<li>这里可以释放分配的全局资源、清理钩子等。</li>
<li><strong>当前没有任何操作，直接跳过。</strong></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">return TRUE;</span><br></pre></td></tr></table></figure>

<ul>
<li>表示函数执行成功。</li>
<li>如果返回 <code>FALSE</code>，则加载 DLL 的操作会失败，进程会收到错误信息。</li>
<li><strong>作用</strong>：这个代码段在 DLL 加载或卸载时执行初始化或清理工作。</li>
<li><strong>具体功能</strong>：<ul>
<li>当 DLL 被加载时，触发 <code>**DLL_PROCESS_ATTACH**</code>，弹出消息框提示。</li>
<li>其他触发场景（如线程附加&#x2F;分离、进程卸载）都没有额外操作，仅做占位。</li>
</ul>
</li>
</ul>
<h3 id="yoPim">四：钩子回调函数</h3>
不管使用哪种钩子，钩子函数的原型都是一样的。

<p><code>LRESULT CALLBACK &lt;font style=&quot;color:#DF2A3F;&quot;&gt;HookProc&lt;/font&gt; ( int nCode, WPARAM wParam, LPARAM lParam )</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK <span class="title function_">KeyboardProc</span><span class="params">(<span class="type">int</span> nCode, WPARAM wParam, LPARAM lParam)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nCode &gt;= <span class="number">0</span> &amp;&amp; wParam == WM_KEYDOWN) &#123;</span><br><span class="line">        KBDLLHOOKSTRUCT *pKey = (KBDLLHOOKSTRUCT *)lParam;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Key Pressed: %d\n&quot;</span>, pKey-&gt;vkCode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CallNextHookEx(hHook, nCode, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ol>
<li><code>**int nCode**</code>：<ul>
<li>表示钩子事件的类型。</li>
<li><code>**nCode &gt;= 0**</code>：消息是有效的，钩子函数应该处理。</li>
<li><strong>负值</strong>：钩子链中的下一个钩子会直接收到消息，当前钩子回调函数将不会被调用。</li>
</ul>
</li>
<li><code>**WPARAM wParam**</code>：<ul>
<li>指定消息的类型。</li>
<li>例如，<code>WM_KEYDOWN</code> 表示键盘按下事件。</li>
</ul>
</li>
<li><code>**LPARAM lParam**</code>：<ul>
<li>包含事件的附加信息，指向与信息相关的数据结构</li>
<li>当 <code>WH_KEYBOARD_LL</code> 类型钩子被使用时，<code>lParam</code> 是一个指向 <code>KBDLLHOOKSTRUCT</code> 的指针。</li>
</ul>
</li>
</ol>
<h4 id="paXp2">1. `lParam` 的意义</h4>
+ **类型**：`LPARAM` 是一个长整型参数，用于传递附加信息。
+ **内容**：当钩子类型为 `WH_KEYBOARD_LL`（低级键盘钩子）时，`lParam` 是一个指向 `KBDLLHOOKSTRUCT` 结构体的指针。
+ **用途**：我们需要通过将 `lParam` 转换为指针类型（`KBDLLHOOKSTRUCT*`），以便访问结构体中的具体字段。

<h4 id="MoAql">2. `KBDLLHOOKSTRUCT` 结构体</h4>
该结构体定义了键盘事件的详细信息，包括按键的虚拟键码、扫描码等。以下是 `KBDLLHOOKSTRUCT` 的定义（简化版）：

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cpp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">typedef struct tagKBDLLHOOKSTRUCT &#123;</span><br><span class="line">    DWORD vkCode;      // 按键的虚拟键码（如 &#x27;A&#x27; 键对应 65）</span><br><span class="line">    DWORD scanCode;    // 硬件扫描码（键盘硬件相关）</span><br><span class="line">    DWORD flags;       // 标志位（描述事件的附加信息）</span><br><span class="line">    DWORD time;        // 时间戳（事件发生的时间，单位为毫秒）</span><br><span class="line">    ULONG_PTR dwExtraInfo; // 额外信息（一般为 0）</span><br><span class="line">&#125; KBDLLHOOKSTRUCT, *PKBDLLHOOKSTRUCT;</span><br></pre></td></tr></table></figure>

<p>字段解释</p>
<ol>
<li><code>**vkCode**</code><strong>（虚拟键码）</strong><ul>
<li>描述键盘按键的逻辑代码，通常与 Windows API 中的虚拟键码表一致。</li>
<li>例如：<ul>
<li><code>65</code>：A 键。</li>
<li><code>13</code>：回车键（Enter）。</li>
<li><code>27</code>：ESC 键。</li>
</ul>
</li>
<li>这是回调函数中最常用的字段，用于确定用户按下了哪个键。</li>
</ul>
</li>
<li><code>**scanCode**</code><strong>（扫描码）</strong><ul>
<li>键盘硬件生成的代码，与具体的键盘物理布局相关。</li>
<li>通常情况下可以忽略，除非需要处理特殊键盘或键盘驱动。</li>
</ul>
</li>
<li><code>**flags**</code><strong>（标志位）</strong><ul>
<li>描述键盘事件的附加信息，可能的值包括：<ul>
<li><code>LLKHF_EXTENDED</code>（0x01）：扩展键（例如右方向键）。</li>
<li><code>LLKHF_INJECTED</code>（0x10）：事件是由其他程序注入的，而非真实的按键事件。</li>
<li><code>LLKHF_UP</code>（0x80）：键被释放（即松开）。</li>
</ul>
</li>
</ul>
</li>
<li><code>**time**</code><strong>（时间戳）</strong><ul>
<li>表示事件发生的时间（相对于系统启动的时间，单位为毫秒）。</li>
<li>通常用于记录事件顺序或做性能分析。</li>
</ul>
</li>
<li><code>**dwExtraInfo**</code><strong>（额外信息）</strong><ul>
<li>系统保留字段，通常为 <code>0</code>。</li>
<li>某些特殊情况下，驱动程序可能会使用它来传递自定义数据。</li>
</ul>
</li>
</ol>
<h4 id="na5se">3.消息循环</h4>
1. `MSG msg;`

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSG msg;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>**MSG**</code>：是一个结构体类型，用于存储从消息队列中获取的消息。</li>
<li><code>**msg**</code>：是该结构体的实例，用来保存每次从消息队列中获取的消息数据。</li>
</ul>
<ol start="2">
<li><code>while (GetMessage(&amp;msg, NULL, 0, 0))</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>**GetMessage**</code> 函数用于从当前线程的消息队列中获取消息并填充到 <code>msg</code> 结构体中。它的原型如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BOOL <span class="title function_">GetMessage</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPMSG lpMsg,      <span class="comment">// 消息结构体，存储消息信息</span></span></span><br><span class="line"><span class="params">    HWND hWnd,        <span class="comment">// 指定要从哪个窗口的消息队列中取消息，NULL 表示从当前线程的所有队列中取消息</span></span></span><br><span class="line"><span class="params">    UINT wMsgFilterMin, <span class="comment">// 消息类型的最小值（可选）</span></span></span><br><span class="line"><span class="params">    UINT wMsgFilterMax  <span class="comment">// 消息类型的最大值（可选）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<pre><code>- `**&amp;msg**`：`msg` 结构体的指针，`GetMessage` 会填充这个结构体，存储消息的信息。
- `**NULL**`：指示从当前线程的所有窗口队列中获取消息。
- `**0, 0**`：设置过滤的消息范围，这里表示不限制消息类型（即接收所有消息）。
</code></pre>
<ul>
<li><strong>返回值</strong>：<ul>
<li>如果有消息在队列中，<code>GetMessage</code> 返回 <code>TRUE</code>，继续执行循环。</li>
<li>如果消息队列为空或接收到退出消息（如 <code>WM_QUIT</code>），<code>GetMessage</code> 返回 <code>FALSE</code>，退出循环。</li>
</ul>
</li>
<li>这意味着消息循环会一直运行，直到程序结束或接收到退出消息。</li>
</ul>
<ol start="3">
<li><code>TranslateMessage(&amp;msg)</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TranslateMessage(&amp;msg);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>**TranslateMessage**</code> 用于将某些键盘消息（如 <code>WM_KEYDOWN</code>）转换成字符消息（<code>WM_CHAR</code>）。这是因为 Windows 消息系统中，按键按下和字符生成是两种不同的消息：<ul>
<li><code>WM_KEYDOWN</code> 用于表示物理按键被按下。</li>
<li><code>WM_CHAR</code> 用于表示输入的字符。</li>
</ul>
</li>
</ul>
<p><code>TranslateMessage</code> 的主要作用是处理键盘输入，使得当按键（如字母、数字等）被按下时，程序可以接收到字符消息。</p>
<ul>
<li><strong>例子</strong>：按下键盘上的字母键时，<code>TranslateMessage</code> 会将 <code>WM_KEYDOWN</code> 转换为相应的 <code>WM_CHAR</code> 消息，表示用户输入了一个字符。</li>
</ul>
<ol start="4">
<li><code>DispatchMessage(&amp;msg)</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DispatchMessage(&amp;msg);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>**DispatchMessage**</code> 函数将消息分发到目标窗口的窗口过程（Window Procedure），使得程序能够处理该消息。</li>
<li>它会根据 <code>msg</code> 结构体中的 <code>hwnd</code>（窗口句柄）字段找到对应的窗口，并将消息传递给该窗口的窗口过程（<code>WndProc</code> 函数）。</li>
</ul>
<p>例如：</p>
<pre><code>- 如果 `msg` 是一个键盘消息（如 `WM_KEYDOWN`），`DispatchMessage` 会调用目标窗口的窗口过程，传递消息给窗口，窗口过程再根据消息执行相应的操作（例如，更新界面或处理快捷键）。
</code></pre>
<p><strong>这个VM前缀一般代表的是窗口信息，一般表示用户与应用程序进行交互的时候。通过信息来通知应用程序</strong></p>

    </div>

    
    
    

    
   <div>
     <div>
    
        <div style="text-align:center;color: #ccc;font-size:24px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
   </div>
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>jayuyu
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2025/01/22/%E5%88%A9%E7%94%A8%E7%B3%BB%E7%BB%9F%E6%9C%BA%E5%88%B6%E5%8A%A0%E8%BD%BDDLL/" title="我的第一篇博客">http://example.com/2025/01/22/利用系统机制加载DLL/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/01/22/%E6%98%A5%E7%A7%8B%E6%9D%AF2025/" rel="prev" title="春秋杯2025">
      <i class="fa fa-chevron-left"></i> 春秋杯2025
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="<!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC82MDM4Ni8zNjg1Ng==">
  <script type="text/javascript">
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];

        if (typeof LivereTower === 'function') { return; }

        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;

        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  </script>
  <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->
"></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E9%92%A9%E5%AD%90%E9%93%BE%E8%A1%A8"><span class="nav-number">1.</span> <span class="nav-text">一：什么是钩子链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FpPqr"><span class="nav-number">1.0.1.</span> <span class="nav-text">二：回调函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89-SetWindowsHookEx-%E6%B6%88%E6%81%AF%E9%92%A9%E5%AD%90%E6%8A%80%E6%9C%AF"><span class="nav-number">2.</span> <span class="nav-text">三.SetWindowsHookEx 消息钩子技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#iTL1E"><span class="nav-number">2.0.1.</span> <span class="nav-text">三.SetWindowsHookEx 消息钩子技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BBECU"><span class="nav-number">2.0.1.1.</span> <span class="nav-text">1.idhook</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Aq1tS"><span class="nav-number">2.0.1.2.</span> <span class="nav-text">2.HOOKPRC lpfn</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xXZTS"><span class="nav-number">2.0.1.3.</span> <span class="nav-text">3.跨进程的钩子举例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HGoaK"><span class="nav-number">2.0.1.3.1.</span> <span class="nav-text">函数声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mEiiQ"><span class="nav-number">2.0.1.3.2.</span> <span class="nav-text">函数主体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#POceb"><span class="nav-number">2.0.1.3.3.</span> <span class="nav-text">1. 处理 &#96;DLL_PROCESS_ATTACH&#96;</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#iveVr"><span class="nav-number">2.0.1.3.4.</span> <span class="nav-text">3. 处理 &#96;DLL_THREAD_DETACH&#96;</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#uRNZT"><span class="nav-number">2.0.1.3.5.</span> <span class="nav-text">4. 处理 &#96;DLL_PROCESS_DETACH&#96;</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#yoPim"><span class="nav-number">2.0.2.</span> <span class="nav-text">四：钩子回调函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#paXp2"><span class="nav-number">2.0.2.1.</span> <span class="nav-text">1. &#96;lParam&#96; 的意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MoAql"><span class="nav-number">2.0.2.2.</span> <span class="nav-text">2. &#96;KBDLLHOOKSTRUCT&#96; 结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#na5se"><span class="nav-number">2.0.2.3.</span> <span class="nav-text">3.消息循环</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="jayuyu"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">jayuyu</p>
  <div class="site-description" itemprop="description">To the sea of success</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      语雀
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.yuque.com/zhangyu-pfp0o" title="https:&#x2F;&#x2F;www.yuque.com&#x2F;zhangyu-pfp0o" rel="noopener" target="_blank">语雀</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Mon Jan 20 2025 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jayuyu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">14k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共5.4k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  















  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>

<!-- 樱花特效 -->
  
      <script async src="/js/src/fairyDustCursor.js"></script>
  

